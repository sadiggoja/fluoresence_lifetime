# -*- coding: utf-8 -*-
"""cs_for_physics_report

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Kx8VsBfT17gdYZVdpeSK5bN8m7BFZbFB
"""

import numpy as np
import time
import math as mt
import pickle  
from itertools import combinations ,permutations

times=np.array(range(0,1000001, 100), dtype='float')/1e12 #declare times array 0 to 1micro second with 100 ps

molecules={
    'Naphtalene'        : 200.9e-9,
    'Anthracene'        : 5.8e-9, 
    'Benzopyrene'       : 38.6e-9,
    'Pyrene'            : 516.2e-9,
    'Chrysene'          : 57.8e-9,
    'Benzofluoranthene' : 8.9e-9,
} #molecules dictionary

lifetimes=np.array(list(molecules.values())) #get lifetimes of

molecule_names=list(molecules.keys()) #get name of molecules

def florescent(time, lifetime):
  return mt.exp(-(time/lifetime)) #calculate flouresence level

fluoresence_levels=[] #get fluoresence level values of all molecules without A
for i in lifetimes:
  row=np.zeros(10000) #create 1 row per molecule to keep f.levels
  for j in range(10000):
    row[j]= florescent(times[j], i) #calc and append value
  fluoresence_levels.append(row) #append data of molecule
fluoresence_levels=np.array(fluoresence_levels)

def show_errors(error_list, test, data_test, numbers): #show errors between mixture data and guessed data
  for i in range( numbers ):
    print(f'Guessed          {test[error_list[i]]}')
    print(f'Real data        {data_test[error_list[i]]}')

def errors(test, data_test): #find number of errors and their indexes
  errors=0
  error_list= []
  for i in range(10000):
    if test_error(test[i], data_test[i]): #check value that guessed in data is error
      error_list.append(i) #collect index of error
  error_list=np.array(error_list)
  return error_list

def test_error(value1, value2): #check value to determine it is error or not
  if abs(value1-value2) > 1e-10: #if abstract of two value is greater than 10^-10 then it is error
    return True
  return False

def get_sum(a_vals, index_list): # get guessed data with the indexes of molecules and A values
  sum=np.zeros(10000)
  for i in range(len(index_list)):
    sum+=a_vals[i]*fluoresence_levels[index_list[i]]
  return sum

def A_list (size, n): #determine all the possible A values respect to the sum of A and number of molecules

  comb=np.ones(n*(size-n+1)) 
  temp=1

  for i in range(n, n*(size-n+1), n):
    comb[i:i+n]+=temp #prepare data to apply permutation function for taking into consederation same values
    temp+=1 

  a_list=[]
  for i in permutations(comb, n):
    if(sum(i)==size and i not in a_list): #find cases that have sum is equal A sum
      a_list.append(i)
  return np.array(a_list)



def mixture_composition( data_test, num_mixture ): #show result and return error with giving data and number of mixtures
  A_sum=int(data_test[0]) #get A sum from first value of mixture data (t=0 exp=1 and there will be only sum of A)
  less_errors=9999 #minimum error variable
  A_comb=A_list( A_sum , num_mixture ) #get combinations of A
  t_comb=combinations(range(0,6), num_mixture ) #get combination of molecules
  
  for t_vals in combinations(range(0,6), num_mixture ): #iterate all the combinations
    for A_vals in A_list( A_sum , num_mixture ):
      guessed_data= get_sum (A_vals, t_vals) #generate data
      num_of_errors = len( errors( guessed_data, data_test ) ) #get number of errors
      if num_of_errors < less_errors: #compare with lest error, if less than lest, lest will be that
        A_lessErrors=A_vals #keep A combination of less error 
        t_lessErrors=t_vals #keep molecule combination of less error
        less_errors = num_of_errors #keep less error value
        if (less_errors==0): #if it is zero break out of all loops
          break
    else:
      continue
    break

  for i in range(1, len(t_lessErrors)+1): #show molecules and its A values in composition
    print(f' {molecule_names[ t_lessErrors[i-1] ]} ( { lifetimes[ t_lessErrors[i-1] ] } )  A={A_lessErrors[i-1]}')
  return less_errors

"""# Mixture 1"""

with open('mixture1.dat', 'rb') as FID:
  myUnpickler = pickle.Unpickler(FID)
  data=myUnpickler.load()

data1=np.array(data, dtype='float')

#print( f' Mixture 1 with { mixture_composition ( data1, 2 ) } errors ' )

"""# Mixture 4"""

with open('mixture4.dat', 'rb') as FID:
  myUnpickler = pickle.Unpickler(FID)
  data=myUnpickler.load()

data4=np.array(data, dtype='float')

#print( f' Mixture 4 with { mixture_composition ( data4, 3) } errors ' )

"""# Mixture 2

"""

with open('mixture2.dat', 'rb') as FID:
  myUnpickler = pickle.Unpickler(FID)
  data=myUnpickler.load()

data2=np.array(data, dtype='float')

#print( f' Mixture 2 with { mixture_composition ( data2, 3 ) }  errors ' )

"""# Mixture 3

"""

with open('mixture3.dat', 'rb') as FID:
  myUnpickler = pickle.Unpickler(FID)
  data=myUnpickler.load()

data3=np.array(data.copy(), dtype='float')

#print( f' Mixture 3 with { mixture_composition ( data3, 2 ) }  errors ' )

"""# Automaticly guessed how many molecules"""

def mixture_composition2 (data_test): #show result and return error with giving data
  A_sum=int(data_test[0]) #get A sum from first value of mixture data (t=0 exp=1 and there will be only sum of A)
  less_errors=9999 #minimum error variable

  for num_mixture in range(2,7):#iterate number of molecules
    A_comb=A_list( A_sum , num_mixture ) #get combinations of A
    t_comb=combinations(range(0,6), num_mixture ) #get combination of molecules

    for t_vals in combinations(range(0,6), num_mixture ): #iterate all the combinations
      for A_vals in A_list( A_sum , num_mixture ):
        guessed_data= get_sum (A_vals, t_vals) #generate data
        num_of_errors = len( errors( guessed_data, data_test ) ) #get number of errors
        if num_of_errors < less_errors: #compare with lest error, if less than lest, lest will be that
          A_lessErrors=A_vals #keep A combination of less error 
          t_lessErrors=t_vals #keep molecule combination of less error
          less_errors = num_of_errors #keep less error value
          if (less_errors==0): #if it is zero break out of all loops
            break
      else:
        continue
      break
    else:
      continue
    break
  for i in range(1, len(t_lessErrors)+1):
    print(f' {molecule_names[ t_lessErrors[i-1] ]} ( { lifetimes[ t_lessErrors[i-1] ] } )  A={A_lessErrors[i-1]}')
  return less_errors
print ("Mixture 1")
print( f'with { mixture_composition2( data1) }  errors ' )
print("--------------------")
print ("Mixture 2")
print( f'with { mixture_composition2( data2) }  errors ' )
print("--------------------")
print ("Mixture 3")
print( f'with { mixture_composition2( data3) }  errors ' )
print("--------------------")
print ("Mixture 4")
print( f'with { mixture_composition2( data4) }  errors ' )

